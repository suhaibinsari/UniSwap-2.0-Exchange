{"ast":null,"code":"import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useCallback, useEffect, useReducer } from 'react';\nimport { useEthers, useLocalStorage, useBlockNumber, useConfig } from '../../hooks';\nimport { useNotificationsContext } from '../notifications/context';\nimport { TransactionsContext } from './context';\nimport { DEFAULT_STORED_TRANSACTIONS } from './model';\nimport { transactionReducer } from './reducer';\nexport function TransactionProvider(_ref) {\n  let {\n    children\n  } = _ref;\n  const {\n    chainId,\n    library\n  } = useEthers();\n  const blockNumber = useBlockNumber();\n  const {\n    localStorage\n  } = useConfig();\n  const [storage, setStorage] = useLocalStorage(localStorage.transactionPath);\n  const [transactions, dispatch] = useReducer(transactionReducer, storage !== null && storage !== void 0 ? storage : DEFAULT_STORED_TRANSACTIONS);\n  const {\n    addNotification\n  } = useNotificationsContext();\n  useEffect(() => {\n    setStorage(transactions);\n  }, [transactions]);\n  const addTransaction = useCallback(payload => {\n    dispatch({\n      type: 'ADD_TRANSACTION',\n      payload\n    });\n    addNotification({\n      notification: {\n        type: 'transactionStarted',\n        transaction: payload.transaction,\n        submittedAt: payload.submittedAt,\n        transactionName: payload.transactionName\n      },\n      chainId: payload.transaction.chainId\n    });\n  }, [dispatch]);\n  useEffect(() => {\n    const updateTransactions = async () => {\n      var _a;\n      if (!chainId || !library || !blockNumber) {\n        return;\n      }\n      const checkTransaction = async tx => {\n        if (tx.receipt || !shouldCheck(blockNumber, tx)) {\n          return tx;\n        }\n        try {\n          const receipt = await library.getTransactionReceipt(tx.transaction.hash);\n          if (receipt) {\n            const type = receipt.status === 0 ? 'transactionFailed' : 'transactionSucceed';\n            addNotification({\n              notification: {\n                type,\n                submittedAt: Date.now(),\n                transaction: tx.transaction,\n                receipt,\n                transactionName: tx.transactionName\n              },\n              chainId\n            });\n            return Object.assign(Object.assign({}, tx), {\n              receipt\n            });\n          } else {\n            return Object.assign(Object.assign({}, tx), {\n              lastCheckedBlockNumber: blockNumber\n            });\n          }\n        } catch (error) {\n          console.error(`failed to check transaction hash: ${tx.transaction.hash}`, error);\n        }\n        return tx;\n      };\n      const chainTransactions = (_a = transactions[chainId]) !== null && _a !== void 0 ? _a : [];\n      const newTransactions = [];\n      for (const tx of chainTransactions) {\n        const newTransaction = await checkTransaction(tx);\n        newTransactions.push(newTransaction);\n      }\n      dispatch({\n        type: 'UPDATE_TRANSACTIONS',\n        chainId,\n        transactions: newTransactions\n      });\n    };\n    void updateTransactions();\n  }, [chainId, library, blockNumber]);\n  return _jsx(TransactionsContext.Provider, {\n    value: {\n      transactions,\n      addTransaction\n    },\n    children: children\n  });\n}\nfunction shouldCheck(blockNumber, tx) {\n  if (tx.receipt) {\n    return false;\n  }\n  if (!tx.lastCheckedBlockNumber) {\n    return true;\n  }\n  const blocksSinceCheck = blockNumber - tx.lastCheckedBlockNumber;\n  if (blocksSinceCheck < 1) {\n    return false;\n  }\n  const minutesPending = (Date.now() - tx.submittedAt) / 1000 / 60;\n  if (minutesPending > 60) {\n    // every 10 blocks if pending for longer than an hour\n    return blocksSinceCheck > 9;\n  }\n  if (minutesPending > 5) {\n    // every 3 blocks if pending more than 5 minutes\n    return blocksSinceCheck > 2;\n  }\n  // otherwise every block\n  return true;\n}","map":{"version":3,"sources":["../../../../../src/providers/transactions/provider.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useCallback, useEffect, useReducer } from 'react';\nimport { useEthers, useLocalStorage, useBlockNumber, useConfig } from '../../hooks';\nimport { useNotificationsContext } from '../notifications/context';\nimport { TransactionsContext } from './context';\nimport { DEFAULT_STORED_TRANSACTIONS } from './model';\nimport { transactionReducer } from './reducer';\nexport function TransactionProvider({ children }) {\n    const { chainId, library } = useEthers();\n    const blockNumber = useBlockNumber();\n    const { localStorage } = useConfig();\n    const [storage, setStorage] = useLocalStorage(localStorage.transactionPath);\n    const [transactions, dispatch] = useReducer(transactionReducer, storage !== null && storage !== void 0 ? storage : DEFAULT_STORED_TRANSACTIONS);\n    const { addNotification } = useNotificationsContext();\n    useEffect(() => {\n        setStorage(transactions);\n    }, [transactions]);\n    const addTransaction = useCallback((payload) => {\n        dispatch({\n            type: 'ADD_TRANSACTION',\n            payload,\n        });\n        addNotification({\n            notification: {\n                type: 'transactionStarted',\n                transaction: payload.transaction,\n                submittedAt: payload.submittedAt,\n                transactionName: payload.transactionName,\n            },\n            chainId: payload.transaction.chainId,\n        });\n    }, [dispatch]);\n    useEffect(() => {\n        const updateTransactions = async () => {\n            var _a;\n            if (!chainId || !library || !blockNumber) {\n                return;\n            }\n            const checkTransaction = async (tx) => {\n                if (tx.receipt || !shouldCheck(blockNumber, tx)) {\n                    return tx;\n                }\n                try {\n                    const receipt = await library.getTransactionReceipt(tx.transaction.hash);\n                    if (receipt) {\n                        const type = receipt.status === 0 ? 'transactionFailed' : 'transactionSucceed';\n                        addNotification({\n                            notification: {\n                                type,\n                                submittedAt: Date.now(),\n                                transaction: tx.transaction,\n                                receipt,\n                                transactionName: tx.transactionName,\n                            },\n                            chainId,\n                        });\n                        return Object.assign(Object.assign({}, tx), { receipt });\n                    }\n                    else {\n                        return Object.assign(Object.assign({}, tx), { lastCheckedBlockNumber: blockNumber });\n                    }\n                }\n                catch (error) {\n                    console.error(`failed to check transaction hash: ${tx.transaction.hash}`, error);\n                }\n                return tx;\n            };\n            const chainTransactions = (_a = transactions[chainId]) !== null && _a !== void 0 ? _a : [];\n            const newTransactions = [];\n            for (const tx of chainTransactions) {\n                const newTransaction = await checkTransaction(tx);\n                newTransactions.push(newTransaction);\n            }\n            dispatch({ type: 'UPDATE_TRANSACTIONS', chainId, transactions: newTransactions });\n        };\n        void updateTransactions();\n    }, [chainId, library, blockNumber]);\n    return _jsx(TransactionsContext.Provider, { value: { transactions, addTransaction }, children: children });\n}\nfunction shouldCheck(blockNumber, tx) {\n    if (tx.receipt) {\n        return false;\n    }\n    if (!tx.lastCheckedBlockNumber) {\n        return true;\n    }\n    const blocksSinceCheck = blockNumber - tx.lastCheckedBlockNumber;\n    if (blocksSinceCheck < 1) {\n        return false;\n    }\n    const minutesPending = (Date.now() - tx.submittedAt) / 1000 / 60;\n    if (minutesPending > 60) {\n        // every 10 blocks if pending for longer than an hour\n        return blocksSinceCheck > 9;\n    }\n    if (minutesPending > 5) {\n        // every 3 blocks if pending more than 5 minutes\n        return blocksSinceCheck > 2;\n    }\n    // otherwise every block\n    return true;\n}\n//# sourceMappingURL=provider.js.map"]},"metadata":{},"sourceType":"module"}