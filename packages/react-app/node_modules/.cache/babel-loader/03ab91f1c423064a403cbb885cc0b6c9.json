{"ast":null,"code":"import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useCallback, useEffect, useMemo, useReducer, useState } from 'react';\nimport { providers } from 'ethers';\nimport { useConfig } from '../../../hooks';\nimport { ReadonlyNetworksContext } from './context';\nimport { fromEntries } from '../../../helpers/fromEntries';\nimport { networkStatesReducer } from './reducer';\nimport { useWindow } from '../../window';\nimport { isWebSocketProvider } from '../../../helpers';\nconst {\n  Provider,\n  StaticJsonRpcProvider\n} = providers;\nconst getProviderFromConfig = urlOrProviderOrProviderFunction => {\n  if (Provider.isProvider(urlOrProviderOrProviderFunction)) {\n    return urlOrProviderOrProviderFunction;\n  }\n  if (typeof urlOrProviderOrProviderFunction === 'function') {\n    return urlOrProviderOrProviderFunction();\n  }\n  return new StaticJsonRpcProvider(urlOrProviderOrProviderFunction);\n};\nexport const getProvidersFromConfig = readOnlyUrls => fromEntries(Object.entries(readOnlyUrls).map(_ref => {\n  let [chainId, urlOrProviderOrProviderFunction] = _ref;\n  return [chainId, getProviderFromConfig(urlOrProviderOrProviderFunction)];\n}));\nexport function ReadonlyNetworksProvider(_ref2) {\n  let {\n    providerOverrides = {},\n    children\n  } = _ref2;\n  const {\n    readOnlyUrls = {},\n    pollingInterval,\n    pollingIntervals\n  } = useConfig();\n  const {\n    isActive\n  } = useWindow();\n  const [providers, setProviders] = useState(() => Object.assign(Object.assign({}, getProvidersFromConfig(readOnlyUrls)), providerOverrides));\n  const [networkStates, dispatchNetworkState] = useReducer(networkStatesReducer, Object.assign({}, fromEntries(Object.keys(Object.assign(Object.assign({}, readOnlyUrls), providerOverrides)).map(chainId => [chainId, {\n    nonStaticCalls: 0\n  }]))));\n  const getPollingInterval = useCallback(chainId => {\n    var _a;\n    return (_a = pollingIntervals === null || pollingIntervals === void 0 ? void 0 : pollingIntervals[chainId]) !== null && _a !== void 0 ? _a : pollingInterval;\n  }, [pollingInterval, pollingIntervals]);\n  useEffect(() => {\n    setProviders(Object.assign(Object.assign({}, getProvidersFromConfig(readOnlyUrls)), providerOverrides));\n  }, Object.entries(readOnlyUrls).flat());\n  useEffect(() => {\n    for (const [chainId, {\n      nonStaticCalls\n    }] of Object.entries(networkStates)) {\n      const provider = providers[chainId];\n      if (provider) {\n        provider.polling = isActive && nonStaticCalls > 0;\n      }\n    }\n  }, [networkStates, isActive]);\n  useEffect(() => {\n    for (const [chainId, provider] of Object.entries(providers)) {\n      if (!isWebSocketProvider(provider)) {\n        provider.pollingInterval = getPollingInterval(Number(chainId));\n      }\n    }\n  }, [providers, getPollingInterval]);\n  const networks = useMemo(() => ({\n    providers,\n    updateNetworkState: dispatchNetworkState\n  }), [providers, dispatchNetworkState]);\n  return _jsx(ReadonlyNetworksContext.Provider, Object.assign({\n    value: networks\n  }, {\n    children: children\n  }));\n}","map":{"version":3,"sources":["../../../../../../src/providers/network/readonlyNetworks/provider.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useCallback, useEffect, useMemo, useReducer, useState } from 'react';\nimport { providers } from 'ethers';\nimport { useConfig } from '../../../hooks';\nimport { ReadonlyNetworksContext } from './context';\nimport { fromEntries } from '../../../helpers/fromEntries';\nimport { networkStatesReducer } from './reducer';\nimport { useWindow } from '../../window';\nimport { isWebSocketProvider } from '../../../helpers';\nconst { Provider, StaticJsonRpcProvider } = providers;\nconst getProviderFromConfig = (urlOrProviderOrProviderFunction) => {\n    if (Provider.isProvider(urlOrProviderOrProviderFunction)) {\n        return urlOrProviderOrProviderFunction;\n    }\n    if (typeof urlOrProviderOrProviderFunction === 'function') {\n        return urlOrProviderOrProviderFunction();\n    }\n    return new StaticJsonRpcProvider(urlOrProviderOrProviderFunction);\n};\nexport const getProvidersFromConfig = (readOnlyUrls) => fromEntries(Object.entries(readOnlyUrls).map(([chainId, urlOrProviderOrProviderFunction]) => [\n    chainId,\n    getProviderFromConfig(urlOrProviderOrProviderFunction),\n]));\nexport function ReadonlyNetworksProvider({ providerOverrides = {}, children }) {\n    const { readOnlyUrls = {}, pollingInterval, pollingIntervals } = useConfig();\n    const { isActive } = useWindow();\n    const [providers, setProviders] = useState(() => (Object.assign(Object.assign({}, getProvidersFromConfig(readOnlyUrls)), providerOverrides)));\n    const [networkStates, dispatchNetworkState] = useReducer(networkStatesReducer, Object.assign({}, fromEntries(Object.keys(Object.assign(Object.assign({}, readOnlyUrls), providerOverrides)).map((chainId) => [chainId, { nonStaticCalls: 0 }]))));\n    const getPollingInterval = useCallback((chainId) => { var _a; return (_a = pollingIntervals === null || pollingIntervals === void 0 ? void 0 : pollingIntervals[chainId]) !== null && _a !== void 0 ? _a : pollingInterval; }, [\n        pollingInterval,\n        pollingIntervals,\n    ]);\n    useEffect(() => {\n        setProviders(Object.assign(Object.assign({}, getProvidersFromConfig(readOnlyUrls)), providerOverrides));\n    }, Object.entries(readOnlyUrls).flat());\n    useEffect(() => {\n        for (const [chainId, { nonStaticCalls }] of Object.entries(networkStates)) {\n            const provider = providers[chainId];\n            if (provider) {\n                provider.polling = isActive && nonStaticCalls > 0;\n            }\n        }\n    }, [networkStates, isActive]);\n    useEffect(() => {\n        for (const [chainId, provider] of Object.entries(providers)) {\n            if (!isWebSocketProvider(provider)) {\n                provider.pollingInterval = getPollingInterval(Number(chainId));\n            }\n        }\n    }, [providers, getPollingInterval]);\n    const networks = useMemo(() => ({\n        providers,\n        updateNetworkState: dispatchNetworkState,\n    }), [providers, dispatchNetworkState]);\n    return _jsx(ReadonlyNetworksContext.Provider, Object.assign({ value: networks }, { children: children }));\n}\n//# sourceMappingURL=provider.js.map"]},"metadata":{},"sourceType":"module"}