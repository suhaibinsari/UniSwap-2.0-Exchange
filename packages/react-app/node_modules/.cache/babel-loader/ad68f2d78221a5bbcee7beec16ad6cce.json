{"ast":null,"code":"import { decodeUint, fail, wordLength } from '../common';\nexport function decodeAggregate(calldata) {\n  // function aggregate(tuple(address target, bytes callData)[] calls) public returns (tuple(uint256 blockNumber, bytes returnData)[])\n  const errorMethodId = '0x08c379a0';\n  if (calldata.startsWith(errorMethodId)) {\n    throw new Error('Multicall aggregate: call failed');\n  }\n  calldata = calldata.slice(2); // 'remove 0x prefix'\n  const getNumber = offset => decodeUint(calldata.slice(offset * wordLength, (offset + 1) * wordLength));\n  const blockNumber = getNumber(0);\n  // The array offset must be 0x40 - blockNumber + array offset\n  if (getNumber(1) !== 0x40) {\n    fail();\n  }\n  const arraySize = getNumber(2);\n  const calls = [];\n  for (let i = 0; i < arraySize; i++) {\n    // offset of the call number i\n    const callOffset = 2 * getNumber(i + 3) + 3 * wordLength; // * 2 because 1 byte = 2 chars\n    // position of the call if we split calldata in chunks of 32 bytes\n    const pos = callOffset / wordLength;\n    // returnData is encoded as its length and the data itself\n    const returnDataOffset = (pos + 1) * wordLength;\n    const returnDataLength = getNumber(pos);\n    const returnData = calldata.slice(returnDataOffset, returnDataOffset + 2 * returnDataLength); // * 2 because 1 byte = 2 chars\n    calls.push('0x' + returnData);\n  }\n  return [blockNumber, calls];\n}","map":{"version":3,"sources":["../../../../../src/abi/multicall/decoder.ts"],"names":[],"mappings":"AAAA,SAAS,UAAU,EAAE,IAAI,EAAE,UAAU,QAAQ,WAAW;AAExD,OAAM,SAAU,eAAe,CAAC,QAAgB,EAAA;EAC9C;EACA,MAAM,aAAa,GAAG,YAAY;EAClC,IAAI,QAAQ,CAAC,UAAU,CAAC,aAAa,CAAC,EAAE;IACtC,MAAM,IAAI,KAAK,CAAC,kCAAkC,CAAC;EACpD;EACD,QAAQ,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAA,CAAC;EAC7B,MAAM,SAAS,GAAI,MAAc,IAAK,UAAU,CAAC,QAAQ,CAAC,KAAK,CAAC,MAAM,GAAG,UAAU,EAAE,CAAC,MAAM,GAAG,CAAC,IAAI,UAAU,CAAC,CAAC;EAEhH,MAAM,WAAW,GAAG,SAAS,CAAC,CAAC,CAAC;EAChC;EACA,IAAI,SAAS,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE;IACzB,IAAI,EAAE;EACP;EACD,MAAM,SAAS,GAAG,SAAS,CAAC,CAAC,CAAC;EAC9B,MAAM,KAAK,GAAa,EAAE;EAE1B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,SAAS,EAAE,CAAC,EAAE,EAAE;IAClC;IACA,MAAM,UAAU,GAAG,CAAC,GAAG,SAAS,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,GAAG,UAAU,CAAA,CAAC;IACzD;IACA,MAAM,GAAG,GAAG,UAAU,GAAG,UAAU;IACnC;IACA,MAAM,gBAAgB,GAAG,CAAC,GAAG,GAAG,CAAC,IAAI,UAAU;IAC/C,MAAM,gBAAgB,GAAG,SAAS,CAAC,GAAG,CAAC;IACvC,MAAM,UAAU,GAAG,QAAQ,CAAC,KAAK,CAAC,gBAAgB,EAAE,gBAAgB,GAAG,CAAC,GAAG,gBAAgB,CAAC,CAAA,CAAC;IAC7F,KAAK,CAAC,IAAI,CAAC,IAAI,GAAG,UAAU,CAAC;EAC9B;EACD,OAAO,CAAC,WAAW,EAAE,KAAK,CAAC;AAC7B","sourceRoot":"","sourcesContent":["import { decodeUint, fail, wordLength } from '../common';\nexport function decodeAggregate(calldata) {\n    // function aggregate(tuple(address target, bytes callData)[] calls) public returns (tuple(uint256 blockNumber, bytes returnData)[])\n    const errorMethodId = '0x08c379a0';\n    if (calldata.startsWith(errorMethodId)) {\n        throw new Error('Multicall aggregate: call failed');\n    }\n    calldata = calldata.slice(2); // 'remove 0x prefix'\n    const getNumber = (offset) => decodeUint(calldata.slice(offset * wordLength, (offset + 1) * wordLength));\n    const blockNumber = getNumber(0);\n    // The array offset must be 0x40 - blockNumber + array offset\n    if (getNumber(1) !== 0x40) {\n        fail();\n    }\n    const arraySize = getNumber(2);\n    const calls = [];\n    for (let i = 0; i < arraySize; i++) {\n        // offset of the call number i\n        const callOffset = 2 * getNumber(i + 3) + 3 * wordLength; // * 2 because 1 byte = 2 chars\n        // position of the call if we split calldata in chunks of 32 bytes\n        const pos = callOffset / wordLength;\n        // returnData is encoded as its length and the data itself\n        const returnDataOffset = (pos + 1) * wordLength;\n        const returnDataLength = getNumber(pos);\n        const returnData = calldata.slice(returnDataOffset, returnDataOffset + 2 * returnDataLength); // * 2 because 1 byte = 2 chars\n        calls.push('0x' + returnData);\n    }\n    return [blockNumber, calls];\n}\n//# sourceMappingURL=decoder.js.map"]},"metadata":{},"sourceType":"module"}