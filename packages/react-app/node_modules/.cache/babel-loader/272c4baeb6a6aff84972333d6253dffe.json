{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useEffect, useMemo, useReducer } from 'react';\nimport { useDebouncePair, useBlockNumbers } from '../../../hooks';\nimport { MultiChainStatesContext } from './context';\nimport { useConfig, useNetwork } from '../../..';\nimport { useReadonlyNetworks } from '../../network';\nimport { fromEntries } from '../../../helpers/fromEntries';\nimport { performMulticall } from '../common/performMulticall';\nimport { callsReducer, chainStateReducer, multicall1Factory, multicall2Factory } from '../common';\nimport { getCallsForUpdate, getUniqueActiveCalls } from '../../../helpers';\nimport { useDevtoolsReporting } from '../common/useDevtoolsReporting';\nimport { useChainId } from '../../../hooks/useChainId';\nimport { useWindow } from '../../window/context';\nimport { useUpdateNetworksState } from '../../network/readonlyNetworks/context';\nfunction composeChainState(networks, state, multicallAddresses) {\n  return fromEntries(Object.keys(networks).map(chainId => [Number(chainId), {\n    value: state[Number(chainId)],\n    multicallAddress: multicallAddresses[Number(chainId)]\n  }]));\n}\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst stripCall = _a => {\n  var {\n      isStatic,\n      lastUpdatedBlockNumber\n    } = _a,\n    strippedCall = __rest(_a, [\"isStatic\", \"lastUpdatedBlockNumber\"]);\n  return strippedCall;\n};\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function MultiChainStateProvider(_ref) {\n  let {\n    children,\n    multicallAddresses\n  } = _ref;\n  const {\n    multicallVersion,\n    fastMulticallEncoding\n  } = useConfig();\n  const networks = useReadonlyNetworks();\n  const blockNumbers = useBlockNumbers();\n  const {\n    reportError\n  } = useNetwork();\n  const {\n    isActive\n  } = useWindow();\n  const [calls, dispatchCalls] = useReducer(callsReducer, []);\n  const [state, dispatchState] = useReducer(chainStateReducer, {});\n  const updateNetworks = useUpdateNetworksState();\n  const multicall = (multicallVersion === 1 ? multicall1Factory : multicall2Factory)(fastMulticallEncoding !== null && fastMulticallEncoding !== void 0 ? fastMulticallEncoding : false);\n  const [debouncedCalls, debouncedNetworks] = useDebouncePair(calls, networks, 50);\n  const uniqueCalls = useMemo(() => getUniqueActiveCalls(debouncedCalls), [debouncedCalls]);\n  // used for deep equality in hook dependencies\n  const uniqueCallsJSON = JSON.stringify(debouncedCalls.map(stripCall));\n  const chainId = useChainId();\n  useDevtoolsReporting(uniqueCallsJSON, uniqueCalls, chainId !== undefined ? blockNumbers[chainId] : undefined, multicallAddresses);\n  function multicallForChain(chainId, provider) {\n    if (!isActive) {\n      return;\n    }\n    const blockNumber = blockNumbers[chainId];\n    const multicallAddress = multicallAddresses[chainId];\n    if (!provider || !blockNumber) {\n      return;\n    }\n    if (!multicallAddress) {\n      reportError(new Error(`Missing multicall address for chain id ${chainId}`));\n      return;\n    }\n    if (debouncedNetworks !== networks) {\n      // Wait for debounce to catch up.\n      return;\n    }\n    const updatedCalls = getCallsForUpdate(debouncedCalls, {\n      chainId,\n      blockNumber\n    });\n    const callsOnThisChain = getUniqueActiveCalls(updatedCalls);\n    updateNetworks({\n      type: 'UPDATE_NON_STATIC_CALLS_COUNT',\n      chainId,\n      count: calls.filter(call => !call.isStatic && call.chainId === chainId).length\n    });\n    performMulticall(provider, multicall, multicallAddress, blockNumber, callsOnThisChain, dispatchState, chainId, reportError);\n    dispatchCalls({\n      type: 'UPDATE_CALLS',\n      calls,\n      updatedCalls,\n      blockNumber,\n      chainId\n    });\n  }\n  useEffect(() => {\n    var _a, _b;\n    for (const [_chainId, provider] of Object.entries(networks)) {\n      const chainId = Number(_chainId);\n      // chainId is in provider is not the same as the chainId in the state wait for chainId to catch up\n      if (chainId === ((_a = provider.network) === null || _a === void 0 ? void 0 : _a.chainId) || chainId === ((_b = provider._network) === null || _b === void 0 ? void 0 : _b.chainId)) {\n        multicallForChain(chainId, provider);\n      }\n    }\n  }, [networks, multicallAddresses, uniqueCallsJSON, blockNumbers]);\n  const chains = useMemo(() => composeChainState(networks, state, multicallAddresses), [state, multicallAddresses, networks]);\n  const provided = {\n    chains,\n    dispatchCalls\n  };\n  return _jsx(MultiChainStatesContext.Provider, {\n    value: provided,\n    children: children\n  });\n}","map":{"version":3,"sources":["../../../../../../src/providers/chainState/multiChainStates/provider.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useEffect, useMemo, useReducer } from 'react';\nimport { useDebouncePair, useBlockNumbers } from '../../../hooks';\nimport { MultiChainStatesContext } from './context';\nimport { useConfig, useNetwork } from '../../..';\nimport { useReadonlyNetworks } from '../../network';\nimport { fromEntries } from '../../../helpers/fromEntries';\nimport { performMulticall } from '../common/performMulticall';\nimport { callsReducer, chainStateReducer, multicall1Factory, multicall2Factory } from '../common';\nimport { getCallsForUpdate, getUniqueActiveCalls } from '../../../helpers';\nimport { useDevtoolsReporting } from '../common/useDevtoolsReporting';\nimport { useChainId } from '../../../hooks/useChainId';\nimport { useWindow } from '../../window/context';\nimport { useUpdateNetworksState } from '../../network/readonlyNetworks/context';\nfunction composeChainState(networks, state, multicallAddresses) {\n    return fromEntries(Object.keys(networks).map((chainId) => [\n        Number(chainId),\n        {\n            value: state[Number(chainId)],\n            multicallAddress: multicallAddresses[Number(chainId)],\n        },\n    ]));\n}\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst stripCall = (_a) => {\n    var { isStatic, lastUpdatedBlockNumber } = _a, strippedCall = __rest(_a, [\"isStatic\", \"lastUpdatedBlockNumber\"]);\n    return strippedCall;\n};\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function MultiChainStateProvider({ children, multicallAddresses }) {\n    const { multicallVersion, fastMulticallEncoding } = useConfig();\n    const networks = useReadonlyNetworks();\n    const blockNumbers = useBlockNumbers();\n    const { reportError } = useNetwork();\n    const { isActive } = useWindow();\n    const [calls, dispatchCalls] = useReducer(callsReducer, []);\n    const [state, dispatchState] = useReducer(chainStateReducer, {});\n    const updateNetworks = useUpdateNetworksState();\n    const multicall = (multicallVersion === 1 ? multicall1Factory : multicall2Factory)(fastMulticallEncoding !== null && fastMulticallEncoding !== void 0 ? fastMulticallEncoding : false);\n    const [debouncedCalls, debouncedNetworks] = useDebouncePair(calls, networks, 50);\n    const uniqueCalls = useMemo(() => getUniqueActiveCalls(debouncedCalls), [debouncedCalls]);\n    // used for deep equality in hook dependencies\n    const uniqueCallsJSON = JSON.stringify(debouncedCalls.map(stripCall));\n    const chainId = useChainId();\n    useDevtoolsReporting(uniqueCallsJSON, uniqueCalls, chainId !== undefined ? blockNumbers[chainId] : undefined, multicallAddresses);\n    function multicallForChain(chainId, provider) {\n        if (!isActive) {\n            return;\n        }\n        const blockNumber = blockNumbers[chainId];\n        const multicallAddress = multicallAddresses[chainId];\n        if (!provider || !blockNumber) {\n            return;\n        }\n        if (!multicallAddress) {\n            reportError(new Error(`Missing multicall address for chain id ${chainId}`));\n            return;\n        }\n        if (debouncedNetworks !== networks) {\n            // Wait for debounce to catch up.\n            return;\n        }\n        const updatedCalls = getCallsForUpdate(debouncedCalls, { chainId, blockNumber });\n        const callsOnThisChain = getUniqueActiveCalls(updatedCalls);\n        updateNetworks({\n            type: 'UPDATE_NON_STATIC_CALLS_COUNT',\n            chainId,\n            count: calls.filter((call) => !call.isStatic && call.chainId === chainId).length,\n        });\n        performMulticall(provider, multicall, multicallAddress, blockNumber, callsOnThisChain, dispatchState, chainId, reportError);\n        dispatchCalls({ type: 'UPDATE_CALLS', calls, updatedCalls, blockNumber, chainId });\n    }\n    useEffect(() => {\n        var _a, _b;\n        for (const [_chainId, provider] of Object.entries(networks)) {\n            const chainId = Number(_chainId);\n            // chainId is in provider is not the same as the chainId in the state wait for chainId to catch up\n            if (chainId === ((_a = provider.network) === null || _a === void 0 ? void 0 : _a.chainId) || chainId === ((_b = provider._network) === null || _b === void 0 ? void 0 : _b.chainId)) {\n                multicallForChain(chainId, provider);\n            }\n        }\n    }, [networks, multicallAddresses, uniqueCallsJSON, blockNumbers]);\n    const chains = useMemo(() => composeChainState(networks, state, multicallAddresses), [\n        state,\n        multicallAddresses,\n        networks,\n    ]);\n    const provided = { chains, dispatchCalls };\n    return _jsx(MultiChainStatesContext.Provider, { value: provided, children: children });\n}\n//# sourceMappingURL=provider.js.map"]},"metadata":{},"sourceType":"module"}