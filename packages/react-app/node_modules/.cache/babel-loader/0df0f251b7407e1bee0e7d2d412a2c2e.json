{"ast":null,"code":"import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useCallback, useEffect, useReducer, useState } from 'react';\nimport { NetworkContext } from './context';\nimport { defaultNetworkState, networkReducer } from './reducer';\nimport { providers } from 'ethers';\nimport { subscribeToProviderEvents, getInjectedProvider, isWebSocketProvider } from '../../../helpers';\nimport { useLocalStorage, useConfig } from '../../../hooks';\nimport detectEthereumProvider from '@metamask/detect-provider';\nconst Provider = providers.Provider;\nconst Web3Provider = providers.Web3Provider;\nasync function tryToGetAccount(provider) {\n  try {\n    return await provider.getSigner().getAddress();\n  } catch (err) {\n    if (err.code === 'UNSUPPORTED_OPERATION') {\n      // readonly provider\n      return undefined;\n    }\n    throw err;\n  }\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function NetworkProvider(_ref) {\n  let {\n    children,\n    providerOverride\n  } = _ref;\n  const {\n    autoConnect,\n    pollingInterval,\n    noMetamaskDeactivate,\n    pollingIntervals\n  } = useConfig();\n  const [network, dispatch] = useReducer(networkReducer, defaultNetworkState);\n  const [onUnsubscribe, setOnUnsubscribe] = useState(() => () => undefined);\n  const [shouldConnectMetamask, setShouldConnectMetamask] = useLocalStorage('shouldConnectMetamask');\n  const [isLoading, setLoading] = useState(false);\n  const getPollingInterval = useCallback(chainId => {\n    var _a;\n    return (_a = pollingIntervals === null || pollingIntervals === void 0 ? void 0 : pollingIntervals[chainId]) !== null && _a !== void 0 ? _a : pollingInterval;\n  }, [pollingInterval, pollingIntervals]);\n  const activateBrowserWallet = useCallback(async () => {\n    setLoading(true);\n    const injectedProvider = await getInjectedProvider(getPollingInterval);\n    if (!injectedProvider) {\n      reportError(new Error('No injected provider available'));\n      setLoading(false);\n      console.error('No injected provider available'); // we do not want to crash the app when there is no metamask\n      return;\n    }\n    try {\n      await injectedProvider.send('eth_requestAccounts', []);\n      setShouldConnectMetamask(true);\n    } catch (err) {\n      reportError(err);\n      setShouldConnectMetamask(false);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n    return activate(injectedProvider);\n  }, []);\n  useEffect(() => {\n    if (providerOverride) {\n      void activate(providerOverride);\n    }\n  }, [providerOverride]);\n  const update = useCallback(newNetwork => {\n    dispatch({\n      type: 'UPDATE_NETWORK',\n      network: newNetwork\n    });\n  }, [network]);\n  const reportError = useCallback(error => {\n    console.error(error);\n    dispatch({\n      type: 'ADD_ERROR',\n      error\n    });\n  }, []);\n  const deactivate = useCallback(() => {\n    setShouldConnectMetamask(false);\n    update({\n      accounts: []\n    });\n  }, []);\n  const onDisconnect = useCallback(provider => error => {\n    const isMetaMask = provider.provider.isMetaMask;\n    if (!noMetamaskDeactivate || !isMetaMask) {\n      reportError(error);\n      deactivate();\n    }\n  }, []);\n  useEffect(() => {\n    setTimeout(async () => {\n      var _a, _b, _c;\n      try {\n        if (shouldConnectMetamask && autoConnect && !providerOverride) {\n          await detectEthereumProvider();\n          // If window.ethereum._state.accounts is non null but has no items,\n          // it probably means that the user has disconnected Metamask manually.\n          if (shouldConnectMetamask && ((_c = (_b = (_a = window.ethereum) === null || _a === void 0 ? void 0 : _a._state) === null || _b === void 0 ? void 0 : _b.accounts) === null || _c === void 0 ? void 0 : _c.length) === 0) {\n            return;\n          }\n          await activateBrowserWallet();\n        }\n      } catch (err) {\n        console.warn(err);\n      }\n    });\n  }, [shouldConnectMetamask, autoConnect, providerOverride]);\n  const activate = useCallback(async provider => {\n    var _a;\n    const wrappedProvider = Provider.isProvider(provider) ? provider : new Web3Provider(provider);\n    try {\n      setLoading(true);\n      const account = await tryToGetAccount(wrappedProvider);\n      const chainId = (_a = await wrappedProvider.getNetwork()) === null || _a === void 0 ? void 0 : _a.chainId;\n      onUnsubscribe();\n      const clearSubscriptions = subscribeToProviderEvents(wrappedProvider.provider, update, onDisconnect(wrappedProvider), chainId => {\n        if (!isWebSocketProvider(wrappedProvider)) {\n          wrappedProvider.pollingInterval = getPollingInterval(chainId);\n        }\n      });\n      setOnUnsubscribe(() => clearSubscriptions);\n      update({\n        provider: wrappedProvider,\n        chainId,\n        accounts: account ? [account] : []\n      });\n    } catch (err) {\n      reportError(err);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  }, [onUnsubscribe]);\n  return _jsx(NetworkContext.Provider, {\n    value: {\n      network,\n      update,\n      activate,\n      deactivate,\n      reportError,\n      activateBrowserWallet,\n      isLoading\n    },\n    children: children\n  });\n}","map":{"version":3,"sources":["../../../../../../src/providers/network/network/provider.tsx"],"names":[],"mappings":";AAAA,SAAoB,WAAW,EAAE,SAAS,EAAE,UAAU,EAAE,QAAQ,QAAQ,OAAO;AAC/E,SAAS,cAAc,QAAQ,WAAW;AAC1C,SAAS,mBAAmB,EAAE,cAAc,QAAQ,WAAW;AAE/D,SAAS,SAAS,QAAQ,QAAQ;AAClC,SAAS,yBAAyB,EAAE,mBAAmB,EAAE,mBAAmB,QAAQ,kBAAkB;AACtG,SAAS,eAAe,EAAE,SAAS,QAAQ,gBAAgB;AAC3D,OAAO,sBAAsB,MAAM,2BAA2B;AAI9D,MAAM,QAAQ,GAAG,SAAS,CAAC,QAAQ;AACnC,MAAM,YAAY,GAAG,SAAS,CAAC,YAAY;AAO3C,eAAe,eAAe,CAAC,QAAyB,EAAA;EACtD,IAAI;IACF,OAAO,MAAM,QAAQ,CAAC,SAAS,EAAE,CAAC,UAAU,EAAE;GAC/C,CAAC,OAAO,GAAQ,EAAE;IACjB,IAAI,GAAG,CAAC,IAAI,KAAK,uBAAuB,EAAE;MACxC;MACA,OAAO,SAAS;IACjB;IACD,MAAM,GAAG;EACV;AACH;AAEA;;AAEG;AACH,OAAM,SAAU,eAAe,OAAqD;EAAA,IAApD;IAAE,QAAQ;IAAE;EAAgB,CAAwB;EAClF,MAAM;IAAE,WAAW;IAAE,eAAe;IAAE,oBAAoB;IAAE;EAAgB,CAAE,GAAG,SAAS,EAAE;EAE5F,MAAM,CAAC,OAAO,EAAE,QAAQ,CAAC,GAAG,UAAU,CAAC,cAAc,EAAE,mBAAmB,CAAC;EAC3E,MAAM,CAAC,aAAa,EAAE,gBAAgB,CAAC,GAAG,QAAQ,CAAa,MAAM,MAAM,SAAS,CAAC;EACrF,MAAM,CAAC,qBAAqB,EAAE,wBAAwB,CAAC,GAAG,eAAe,CAAC,uBAAuB,CAAC;EAClG,MAAM,CAAC,SAAS,EAAE,UAAU,CAAC,GAAG,QAAQ,CAAC,KAAK,CAAC;EAC/C,MAAM,kBAAkB,GAAG,WAAW,CAAE,OAAe,IAAI;IAAA,IAAA,EAAA;IAAC,OAAA,CAAA,EAAA,GAAA,gBAAgB,KAAA,IAAA,IAAhB,gBAAgB,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAhB,gBAAgB,CAAG,OAAO,CAAC,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,eAAe;EAAA,CAAA,EAAE,CAC1G,eAAe,EACf,gBAAgB,CACjB,CAAC;EAEF,MAAM,qBAAqB,GAAG,WAAW,CAAC,YAAW;IACnD,UAAU,CAAC,IAAI,CAAC;IAChB,MAAM,gBAAgB,GAAG,MAAM,mBAAmB,CAAC,kBAAkB,CAAC;IAEtE,IAAI,CAAC,gBAAgB,EAAE;MACrB,WAAW,CAAC,IAAI,KAAK,CAAC,gCAAgC,CAAC,CAAC;MACxD,UAAU,CAAC,KAAK,CAAC;MACjB,OAAO,CAAC,KAAK,CAAC,gCAAgC,CAAC,CAAA,CAAC;MAChD;IACD;IACD,IAAI;MACF,MAAM,gBAAgB,CAAC,IAAI,CAAC,qBAAqB,EAAE,EAAE,CAAC;MACtD,wBAAwB,CAAC,IAAI,CAAC;KAC/B,CAAC,OAAO,GAAQ,EAAE;MACjB,WAAW,CAAC,GAAG,CAAC;MAChB,wBAAwB,CAAC,KAAK,CAAC;MAC/B,MAAM,GAAG;KACV,SAAS;MACR,UAAU,CAAC,KAAK,CAAC;IAClB;IACD,OAAO,QAAQ,CAAC,gBAAgB,CAAC;EACnC,CAAC,EAAE,EAAE,CAAC;EAEN,SAAS,CAAC,MAAK;IACb,IAAI,gBAAgB,EAAE;MACpB,KAAK,QAAQ,CAAC,gBAAgB,CAAC;IAChC;EACH,CAAC,EAAE,CAAC,gBAAgB,CAAC,CAAC;EACtB,MAAM,MAAM,GAAG,WAAW,CACvB,UAA4B,IAAI;IAC/B,QAAQ,CAAC;MAAE,IAAI,EAAE,gBAAgB;MAAE,OAAO,EAAE;IAAU,CAAE,CAAC;EAC3D,CAAC,EACD,CAAC,OAAO,CAAC,CACV;EAED,MAAM,WAAW,GAAG,WAAW,CAAE,KAAY,IAAI;IAC/C,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC;IACpB,QAAQ,CAAC;MAAE,IAAI,EAAE,WAAW;MAAE;IAAK,CAAE,CAAC;EACxC,CAAC,EAAE,EAAE,CAAC;EAEN,MAAM,UAAU,GAAG,WAAW,CAAC,MAAK;IAClC,wBAAwB,CAAC,KAAK,CAAC;IAC/B,MAAM,CAAC;MACL,QAAQ,EAAE;KACX,CAAC;EACJ,CAAC,EAAE,EAAE,CAAC;EAEN,MAAM,YAAY,GAAG,WAAW,CAC7B,QAAyB,IAAM,KAAU,IAAI;IAC5C,MAAM,UAAU,GAAI,QAAgB,CAAC,QAAQ,CAAC,UAAU;IACxD,IAAI,CAAC,oBAAoB,IAAI,CAAC,UAAU,EAAE;MACxC,WAAW,CAAC,KAAK,CAAC;MAClB,UAAU,EAAE;IACb;EACH,CAAC,EACD,EAAE,CACH;EAED,SAAS,CAAC,MAAK;IACb,UAAU,CAAC,YAAW;;MACpB,IAAI;QACF,IAAI,qBAAqB,IAAI,WAAW,IAAI,CAAC,gBAAgB,EAAE;UAC7D,MAAM,sBAAsB,EAAE;UAE9B;UACA;UACA,IAAI,qBAAqB,IAAI,CAAA,CAAA,EAAA,GAAA,CAAA,EAAA,GAAA,CAAA,EAAA,GAAC,MAAM,CAAC,QAAgB,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAE,MAAM,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAE,QAAQ,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAE,MAAM,MAAK,CAAC,EAAE;YACrF;UACD;UAED,MAAM,qBAAqB,EAAE;QAC9B;OACF,CAAC,OAAO,GAAG,EAAE;QACZ,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC;MAClB;IACH,CAAC,CAAC;EACJ,CAAC,EAAE,CAAC,qBAAqB,EAAE,WAAW,EAAE,gBAAgB,CAAC,CAAC;EAE1D,MAAM,QAAQ,GAAG,WAAW,CAC1B,MAAO,QAA4C,IAAI;;IACrD,MAAM,eAAe,GAAG,QAAQ,CAAC,UAAU,CAAC,QAAQ,CAAC,GAAG,QAAQ,GAAG,IAAI,YAAY,CAAC,QAAQ,CAAC;IAC7F,IAAI;MACF,UAAU,CAAC,IAAI,CAAC;MAChB,MAAM,OAAO,GAAG,MAAM,eAAe,CAAC,eAAe,CAAC;MACtD,MAAM,OAAO,GAAG,CAAA,EAAA,GAAC,MAAM,eAAe,CAAC,UAAU,EAAG,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAE,OAAO;MAC7D,aAAa,EAAE;MACf,MAAM,kBAAkB,GAAG,yBAAyB,CACjD,eAAuB,CAAC,QAAQ,EACjC,MAAM,EACN,YAAY,CAAC,eAAe,CAAC,EAC5B,OAAO,IAAI;QACV,IAAI,CAAC,mBAAmB,CAAC,eAAe,CAAC,EAAE;UACzC,eAAe,CAAC,eAAe,GAAG,kBAAkB,CAAC,OAAO,CAAC;QAC9D;MACH,CAAC,CACF;MACD,gBAAgB,CAAC,MAAM,kBAAkB,CAAC;MAC1C,MAAM,CAAC;QACL,QAAQ,EAAE,eAAe;QACzB,OAAO;QACP,QAAQ,EAAE,OAAO,GAAG,CAAC,OAAO,CAAC,GAAG;OACjC,CAAC;KACH,CAAC,OAAO,GAAQ,EAAE;MACjB,WAAW,CAAC,GAAG,CAAC;MAChB,MAAM,GAAG;KACV,SAAS;MACR,UAAU,CAAC,KAAK,CAAC;IAClB;EACH,CAAC,EACD,CAAC,aAAa,CAAC,CAChB;EACD,OACE,IAAA,CAAC,cAAc,CAAC,QAAQ,EAAA;IACtB,KAAK,EAAE;MAAE,OAAO;MAAE,MAAM;MAAE,QAAQ;MAAE,UAAU;MAAE,WAAW;MAAE,qBAAqB;MAAE;IAAS,CAAE;IAC/F,QAAQ,EAAE;EAAQ,CAAA,CAClB;AAEN","sourceRoot":"","sourcesContent":["import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useCallback, useEffect, useReducer, useState } from 'react';\nimport { NetworkContext } from './context';\nimport { defaultNetworkState, networkReducer } from './reducer';\nimport { providers } from 'ethers';\nimport { subscribeToProviderEvents, getInjectedProvider, isWebSocketProvider } from '../../../helpers';\nimport { useLocalStorage, useConfig } from '../../../hooks';\nimport detectEthereumProvider from '@metamask/detect-provider';\nconst Provider = providers.Provider;\nconst Web3Provider = providers.Web3Provider;\nasync function tryToGetAccount(provider) {\n    try {\n        return await provider.getSigner().getAddress();\n    }\n    catch (err) {\n        if (err.code === 'UNSUPPORTED_OPERATION') {\n            // readonly provider\n            return undefined;\n        }\n        throw err;\n    }\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function NetworkProvider({ children, providerOverride }) {\n    const { autoConnect, pollingInterval, noMetamaskDeactivate, pollingIntervals } = useConfig();\n    const [network, dispatch] = useReducer(networkReducer, defaultNetworkState);\n    const [onUnsubscribe, setOnUnsubscribe] = useState(() => () => undefined);\n    const [shouldConnectMetamask, setShouldConnectMetamask] = useLocalStorage('shouldConnectMetamask');\n    const [isLoading, setLoading] = useState(false);\n    const getPollingInterval = useCallback((chainId) => { var _a; return (_a = pollingIntervals === null || pollingIntervals === void 0 ? void 0 : pollingIntervals[chainId]) !== null && _a !== void 0 ? _a : pollingInterval; }, [\n        pollingInterval,\n        pollingIntervals,\n    ]);\n    const activateBrowserWallet = useCallback(async () => {\n        setLoading(true);\n        const injectedProvider = await getInjectedProvider(getPollingInterval);\n        if (!injectedProvider) {\n            reportError(new Error('No injected provider available'));\n            setLoading(false);\n            console.error('No injected provider available'); // we do not want to crash the app when there is no metamask\n            return;\n        }\n        try {\n            await injectedProvider.send('eth_requestAccounts', []);\n            setShouldConnectMetamask(true);\n        }\n        catch (err) {\n            reportError(err);\n            setShouldConnectMetamask(false);\n            throw err;\n        }\n        finally {\n            setLoading(false);\n        }\n        return activate(injectedProvider);\n    }, []);\n    useEffect(() => {\n        if (providerOverride) {\n            void activate(providerOverride);\n        }\n    }, [providerOverride]);\n    const update = useCallback((newNetwork) => {\n        dispatch({ type: 'UPDATE_NETWORK', network: newNetwork });\n    }, [network]);\n    const reportError = useCallback((error) => {\n        console.error(error);\n        dispatch({ type: 'ADD_ERROR', error });\n    }, []);\n    const deactivate = useCallback(() => {\n        setShouldConnectMetamask(false);\n        update({\n            accounts: [],\n        });\n    }, []);\n    const onDisconnect = useCallback((provider) => (error) => {\n        const isMetaMask = provider.provider.isMetaMask;\n        if (!noMetamaskDeactivate || !isMetaMask) {\n            reportError(error);\n            deactivate();\n        }\n    }, []);\n    useEffect(() => {\n        setTimeout(async () => {\n            var _a, _b, _c;\n            try {\n                if (shouldConnectMetamask && autoConnect && !providerOverride) {\n                    await detectEthereumProvider();\n                    // If window.ethereum._state.accounts is non null but has no items,\n                    // it probably means that the user has disconnected Metamask manually.\n                    if (shouldConnectMetamask && ((_c = (_b = (_a = window.ethereum) === null || _a === void 0 ? void 0 : _a._state) === null || _b === void 0 ? void 0 : _b.accounts) === null || _c === void 0 ? void 0 : _c.length) === 0) {\n                        return;\n                    }\n                    await activateBrowserWallet();\n                }\n            }\n            catch (err) {\n                console.warn(err);\n            }\n        });\n    }, [shouldConnectMetamask, autoConnect, providerOverride]);\n    const activate = useCallback(async (provider) => {\n        var _a;\n        const wrappedProvider = Provider.isProvider(provider) ? provider : new Web3Provider(provider);\n        try {\n            setLoading(true);\n            const account = await tryToGetAccount(wrappedProvider);\n            const chainId = (_a = (await wrappedProvider.getNetwork())) === null || _a === void 0 ? void 0 : _a.chainId;\n            onUnsubscribe();\n            const clearSubscriptions = subscribeToProviderEvents(wrappedProvider.provider, update, onDisconnect(wrappedProvider), (chainId) => {\n                if (!isWebSocketProvider(wrappedProvider)) {\n                    wrappedProvider.pollingInterval = getPollingInterval(chainId);\n                }\n            });\n            setOnUnsubscribe(() => clearSubscriptions);\n            update({\n                provider: wrappedProvider,\n                chainId,\n                accounts: account ? [account] : [],\n            });\n        }\n        catch (err) {\n            reportError(err);\n            throw err;\n        }\n        finally {\n            setLoading(false);\n        }\n    }, [onUnsubscribe]);\n    return (_jsx(NetworkContext.Provider, { value: { network, update, activate, deactivate, reportError, activateBrowserWallet, isLoading }, children: children }));\n}\n//# sourceMappingURL=provider.js.map"]},"metadata":{},"sourceType":"module"}