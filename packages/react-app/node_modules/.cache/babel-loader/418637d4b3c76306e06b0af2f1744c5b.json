{"ast":null,"code":"import { useConfig } from './useConfig';\nimport { useCallback, useState } from 'react';\nimport { useEthers } from './useEthers';\nimport { estimateContractFunctionGasLimit, usePromiseTransaction } from './usePromiseTransaction';\nimport { useReadonlyNetworks } from '../providers';\nimport { getSignerFromOptions } from '../helpers/getSignerFromOptions';\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function connectContractToSigner(contract, options, librarySigner) {\n  if (contract.signer) {\n    return contract;\n  }\n  if (options && 'signer' in options) {\n    return contract.connect(options.signer);\n  }\n  if (librarySigner) {\n    return contract.connect(librarySigner);\n  }\n  throw new TypeError('No signer available in contract, options or library');\n}\n/**\n * Hook returns an object with four variables: ``state`` , ``send``, ``events`` , and ``resetState``.\n *\n * The `state` represents the status of transaction. See {@link TransactionStatus}.\n *\n * `resetState` can be used to reset the state to `None` after a transaction attempt has either succeeded or failed.\n *\n * The `events` is a array of parsed transaction events of type [LogDescription](https://docs.ethers.io/v5/api/utils/abi/interface/#LogDescription).\n *\n * To send a transaction use `send` function returned by `useContractFunction`.\n * The function forwards arguments to ethers.js contract object, so that arguments map 1 to 1 with Solidity function arguments.\n * Additionally, there can be one extra argument - [TransactionOverrides](https://docs.ethers.io/v5/api/contract/contract/#contract-functionsSend), which can be used to manipulate transaction parameters like gasPrice, nonce, etc\n *\n * If typechain contract is supplied as contract parameter then function name and send arguments will be type checked.\n * More on type checking [here](https://usedapp-docs.netlify.app/docs/Guides/Reading/Typechain).\n * @public\n * @param contract contract which function is to be called , also see [Contract](https://docs.ethers.io/v5/api/contract/contract/)\n * @param functionName name of function to call\n * @param options additional options of type {@link TransactionOptions}\n * @returns {} object with variables: `send` , `state` , `events`: `{ send: (...args: any[]) => void, state: TransactionStatus, events: LogDescription[] }`.\n *\n * @example\n * const { state, send } = useContractFunction(contract, 'deposit', { transactionName: 'Wrap' })\n *\n * const depositEther = (etherAmount: string) => {\n *   send({ value: utils.parseEther(etherAmount) })\n * }\n * @example\n * const { state, send } = useContractFunction(contract, 'withdraw', { transactionName: 'Unwrap' })\n *\n * const withdrawEther = (wethAmount: string) => {\n *   send(utils.parseEther(wethAmount))\n * }\n */\nexport function useContractFunction(contract, functionName, options) {\n  var _a, _b, _c;\n  const {\n    library,\n    chainId\n  } = useEthers();\n  const transactionChainId = options && 'chainId' in options && (options === null || options === void 0 ? void 0 : options.chainId) || chainId;\n  const {\n    promiseTransaction,\n    state,\n    resetState\n  } = usePromiseTransaction(transactionChainId, options);\n  const [events, setEvents] = useState(undefined);\n  const config = useConfig();\n  const gasLimitBufferPercentage = (_c = (_b = (_a = options === null || options === void 0 ? void 0 : options.gasLimitBufferPercentage) !== null && _a !== void 0 ? _a : options === null || options === void 0 ? void 0 : options.bufferGasLimitPercentage) !== null && _b !== void 0 ? _b : config === null || config === void 0 ? void 0 : config.gasLimitBufferPercentage) !== null && _c !== void 0 ? _c : 0;\n  const providers = useReadonlyNetworks();\n  const provider = transactionChainId && providers[transactionChainId];\n  const send = useCallback(async function () {\n    var _a, _b;\n    if (contract) {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      const hasOpts = args.length > ((_b = (_a = contract.interface) === null || _a === void 0 ? void 0 : _a.getFunction(functionName).inputs.length) !== null && _b !== void 0 ? _b : 0);\n      const signer = getSignerFromOptions(provider, options, library);\n      const contractWithSigner = connectContractToSigner(contract, options, signer);\n      const opts = hasOpts ? args[args.length - 1] : undefined;\n      const gasLimit = await estimateContractFunctionGasLimit(contractWithSigner, functionName, args, gasLimitBufferPercentage);\n      const modifiedOpts = Object.assign({\n        gasLimit\n      }, opts);\n      const modifiedArgs = hasOpts ? args.slice(0, args.length - 1) : args;\n      modifiedArgs.push(modifiedOpts);\n      const receipt = await promiseTransaction(contractWithSigner[functionName](...modifiedArgs));\n      if (receipt === null || receipt === void 0 ? void 0 : receipt.logs) {\n        const events = receipt.logs.reduce((accumulatedLogs, log) => {\n          try {\n            return log.address.toLowerCase() === contract.address.toLowerCase() ? [...accumulatedLogs, contract.interface.parseLog(log)] : accumulatedLogs;\n          } catch (_err) {\n            return accumulatedLogs;\n          }\n        }, []);\n        setEvents(events);\n      }\n      return receipt;\n    }\n  }, [contract, functionName, options, provider, library, gasLimitBufferPercentage, promiseTransaction]);\n  return {\n    send,\n    state,\n    events,\n    resetState\n  };\n}","map":{"version":3,"sources":["../../../../src/hooks/useContractFunction.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { useConfig } from './useConfig';\nimport { useCallback, useState } from 'react';\nimport { useEthers } from './useEthers';\nimport { estimateContractFunctionGasLimit, usePromiseTransaction } from './usePromiseTransaction';\nimport { useReadonlyNetworks } from '../providers';\nimport { getSignerFromOptions } from '../helpers/getSignerFromOptions';\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function connectContractToSigner(contract, options, librarySigner) {\n    if (contract.signer) {\n        return contract;\n    }\n    if (options && 'signer' in options) {\n        return contract.connect(options.signer);\n    }\n    if (librarySigner) {\n        return contract.connect(librarySigner);\n    }\n    throw new TypeError('No signer available in contract, options or library');\n}\n/**\n * Hook returns an object with four variables: ``state`` , ``send``, ``events`` , and ``resetState``.\n *\n * The `state` represents the status of transaction. See {@link TransactionStatus}.\n *\n * `resetState` can be used to reset the state to `None` after a transaction attempt has either succeeded or failed.\n *\n * The `events` is a array of parsed transaction events of type [LogDescription](https://docs.ethers.io/v5/api/utils/abi/interface/#LogDescription).\n *\n * To send a transaction use `send` function returned by `useContractFunction`.\n * The function forwards arguments to ethers.js contract object, so that arguments map 1 to 1 with Solidity function arguments.\n * Additionally, there can be one extra argument - [TransactionOverrides](https://docs.ethers.io/v5/api/contract/contract/#contract-functionsSend), which can be used to manipulate transaction parameters like gasPrice, nonce, etc\n *\n * If typechain contract is supplied as contract parameter then function name and send arguments will be type checked.\n * More on type checking [here](https://usedapp-docs.netlify.app/docs/Guides/Reading/Typechain).\n * @public\n * @param contract contract which function is to be called , also see [Contract](https://docs.ethers.io/v5/api/contract/contract/)\n * @param functionName name of function to call\n * @param options additional options of type {@link TransactionOptions}\n * @returns {} object with variables: `send` , `state` , `events`: `{ send: (...args: any[]) => void, state: TransactionStatus, events: LogDescription[] }`.\n *\n * @example\n * const { state, send } = useContractFunction(contract, 'deposit', { transactionName: 'Wrap' })\n *\n * const depositEther = (etherAmount: string) => {\n *   send({ value: utils.parseEther(etherAmount) })\n * }\n * @example\n * const { state, send } = useContractFunction(contract, 'withdraw', { transactionName: 'Unwrap' })\n *\n * const withdrawEther = (wethAmount: string) => {\n *   send(utils.parseEther(wethAmount))\n * }\n */\nexport function useContractFunction(contract, functionName, options) {\n    var _a, _b, _c;\n    const { library, chainId } = useEthers();\n    const transactionChainId = (options && 'chainId' in options && (options === null || options === void 0 ? void 0 : options.chainId)) || chainId;\n    const { promiseTransaction, state, resetState } = usePromiseTransaction(transactionChainId, options);\n    const [events, setEvents] = useState(undefined);\n    const config = useConfig();\n    const gasLimitBufferPercentage = (_c = (_b = (_a = options === null || options === void 0 ? void 0 : options.gasLimitBufferPercentage) !== null && _a !== void 0 ? _a : options === null || options === void 0 ? void 0 : options.bufferGasLimitPercentage) !== null && _b !== void 0 ? _b : config === null || config === void 0 ? void 0 : config.gasLimitBufferPercentage) !== null && _c !== void 0 ? _c : 0;\n    const providers = useReadonlyNetworks();\n    const provider = (transactionChainId && providers[transactionChainId]);\n    const send = useCallback(async (...args) => {\n        var _a, _b;\n        if (contract) {\n            const hasOpts = args.length > ((_b = (_a = contract.interface) === null || _a === void 0 ? void 0 : _a.getFunction(functionName).inputs.length) !== null && _b !== void 0 ? _b : 0);\n            const signer = getSignerFromOptions(provider, options, library);\n            const contractWithSigner = connectContractToSigner(contract, options, signer);\n            const opts = hasOpts ? args[args.length - 1] : undefined;\n            const gasLimit = await estimateContractFunctionGasLimit(contractWithSigner, functionName, args, gasLimitBufferPercentage);\n            const modifiedOpts = Object.assign({ gasLimit }, opts);\n            const modifiedArgs = hasOpts ? args.slice(0, args.length - 1) : args;\n            modifiedArgs.push(modifiedOpts);\n            const receipt = await promiseTransaction(contractWithSigner[functionName](...modifiedArgs));\n            if (receipt === null || receipt === void 0 ? void 0 : receipt.logs) {\n                const events = receipt.logs.reduce((accumulatedLogs, log) => {\n                    try {\n                        return log.address.toLowerCase() === contract.address.toLowerCase()\n                            ? [...accumulatedLogs, contract.interface.parseLog(log)]\n                            : accumulatedLogs;\n                    }\n                    catch (_err) {\n                        return accumulatedLogs;\n                    }\n                }, []);\n                setEvents(events);\n            }\n            return receipt;\n        }\n    }, [contract, functionName, options, provider, library, gasLimitBufferPercentage, promiseTransaction]);\n    return { send, state, events, resetState };\n}\n//# sourceMappingURL=useContractFunction.js.map"]},"metadata":{},"sourceType":"module"}