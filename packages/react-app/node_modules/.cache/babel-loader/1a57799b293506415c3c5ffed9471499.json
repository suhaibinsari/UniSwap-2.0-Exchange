{"ast":null,"code":"import { useMemo } from 'react';\nimport { useChainCalls } from './useChainCalls';\nimport { useChainId } from './useChainId';\nfunction warnOnInvalidContractCall(call) {\n  console.warn(`Invalid contract call: address=${call && call.address} method=${call && call.method} args=${call && call.args}`);\n}\nfunction encodeCallData(call, chainId) {\n  if (!call) {\n    return undefined;\n  }\n  if (!call.address || !call.method) {\n    warnOnInvalidContractCall(call);\n    return undefined;\n  }\n  try {\n    return {\n      address: call.address,\n      data: call.abi.encodeFunctionData(call.method, call.args),\n      chainId\n    };\n  } catch (_a) {\n    warnOnInvalidContractCall(call);\n    return undefined;\n  }\n}\n/**\n * Makes a call to a specific contract and returns the value. The hook will cause the component to refresh when a new block is mined and the return value changes.\n * A syntax sugar for {@link useChainCall} that uses ABI, function name, and arguments instead of raw data.\n * @public\n * @param call a single call to a contract, also see {@link ContractCall}.\n * @deprecated It is recommended to use {@link useCall} instead of this method as it is deprecated.\n * @returns the result of a call or undefined if call didn't return yet.\n */\nexport function useContractCall(call) {\n  let queryParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return useContractCalls([call], queryParams)[0];\n}\n/**\n * Makes calls to specific contracts and returns values. The hook will cause the component to refresh when a new block is mined and the return values change.\n * A syntax sugar for {@link useChainCalls} that uses ABI, function name, and arguments instead of raw data.\n * @public\n * @param calls a list of contract calls , also see {@link ContractCall}.\n * @deprecated It is recommended to use {@link useCalls} instead of this method as it is deprecated.\n * @returns array of results. Undefined if call didn't return yet.\n */\nexport function useContractCalls(calls) {\n  let queryParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const chainId = useChainId({\n    queryParams\n  });\n  const rawCalls = useMemo(() => calls.map(call => chainId !== undefined ? encodeCallData(call, chainId) : undefined), [JSON.stringify(calls.map(call => {\n    var _a;\n    return call && {\n      address: (_a = call.address) === null || _a === void 0 ? void 0 : _a.toLowerCase(),\n      method: call.method,\n      args: call.args\n    };\n  })), chainId]);\n  const results = useChainCalls(rawCalls);\n  return useMemo(() => results.map((result, idx) => {\n    const call = calls[idx];\n    if (result === '0x') {\n      warnOnInvalidContractCall(call);\n      return undefined;\n    }\n    return call && result ? call.abi.decodeFunctionResult(call.method, result) : undefined;\n  }), [JSON.stringify(results)]);\n}","map":{"version":3,"sources":["../../../../src/hooks/useContractCall.ts"],"names":[],"mappings":"AACA,SAAS,OAAO,QAAQ,OAAO;AAK/B,SAAS,aAAa,QAAQ,iBAAiB;AAC/C,SAAS,UAAU,QAAQ,cAAc;AAEzC,SAAS,yBAAyB,CAAC,IAA0B,EAAA;EAC3D,OAAO,CAAC,IAAI,CACV,kCAAkC,IAAI,IAAI,IAAI,CAAC,OAAO,WAAW,IAAI,IAAI,IAAI,CAAC,MAAM,SAAS,IAAI,IAAI,IAAI,CAAC,IAAI,EAAE,CACjH;AACH;AAEA,SAAS,cAAc,CAAC,IAA0B,EAAE,OAAgB,EAAA;EAClE,IAAI,CAAC,IAAI,EAAE;IACT,OAAO,SAAS;EACjB;EACD,IAAI,CAAC,IAAI,CAAC,OAAO,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE;IACjC,yBAAyB,CAAC,IAAI,CAAC;IAC/B,OAAO,SAAS;EACjB;EACD,IAAI;IACF,OAAO;MAAE,OAAO,EAAE,IAAI,CAAC,OAAO;MAAE,IAAI,EAAE,IAAI,CAAC,GAAG,CAAC,kBAAkB,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,IAAI,CAAC;MAAE;IAAO,CAAE;GACrG,CAAC,OAAA,EAAA,EAAM;IACN,yBAAyB,CAAC,IAAI,CAAC;IAC/B,OAAO,SAAS;EACjB;AACH;AAaA;;;;;;;AAOG;AACH,OAAM,SAAU,eAAe,CAAC,IAA0B,EAA+B;EAAA,IAA7B,WAAA,uEAA2B,CAAA,CAAE;EACvF,OAAO,gBAAgB,CAAC,CAAC,IAAI,CAAC,EAAE,WAAW,CAAC,CAAC,CAAC,CAAC;AACjD;AAEA;;;;;;;AAOG;AACH,OAAM,SAAU,gBAAgB,CAC9B,KAA+B,EACF;EAAA,IAA7B,WAAA,uEAA2B,CAAA,CAAE;EAE7B,MAAM,OAAO,GAAG,UAAU,CAAC;IAAE;EAAW,CAAE,CAAC;EAE3C,MAAM,QAAQ,GAAG,OAAO,CACtB,MAAM,KAAK,CAAC,GAAG,CAAE,IAAI,IAAM,OAAO,KAAK,SAAS,GAAG,cAAc,CAAC,IAAI,EAAE,OAAO,CAAC,GAAG,SAAU,CAAC,EAC9F,CACE,IAAI,CAAC,SAAS,CACZ,KAAK,CAAC,GAAG,CAAE,IAAI,IAAI;IAAA,IAAA,EAAA;IAAC,OAAA,IAAI,IAAI;MAAE,OAAO,EAAE,CAAA,EAAA,GAAA,IAAI,CAAC,OAAO,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAE,WAAW,EAAE;MAAE,MAAM,EAAE,IAAI,CAAC,MAAM;MAAE,IAAI,EAAE,IAAI,CAAC;IAAI,CAAE;EAAA,CAAA,CAAC,CAC5G,EACD,OAAO,CACR,CACF;EAED,MAAM,OAAO,GAAG,aAAa,CAAC,QAAQ,CAAC;EAEvC,OAAO,OAAO,CACZ,MACE,OAAO,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,GAAG,KAAI;IAC1B,MAAM,IAAI,GAAG,KAAK,CAAC,GAAG,CAAC;IACvB,IAAI,MAAM,KAAK,IAAI,EAAE;MACnB,yBAAyB,CAAC,IAAI,CAAC;MAC/B,OAAO,SAAS;IACjB;IACD,OAAO,IAAI,IAAI,MAAM,GAAI,IAAI,CAAC,GAAG,CAAC,oBAAoB,CAAC,IAAI,CAAC,MAAM,EAAE,MAAM,CAAW,GAAG,SAAS;EACnG,CAAC,CAAC,EACJ,CAAC,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,CAC1B;AACH","sourceRoot":"","sourcesContent":["import { useMemo } from 'react';\nimport { useChainCalls } from './useChainCalls';\nimport { useChainId } from './useChainId';\nfunction warnOnInvalidContractCall(call) {\n    console.warn(`Invalid contract call: address=${call && call.address} method=${call && call.method} args=${call && call.args}`);\n}\nfunction encodeCallData(call, chainId) {\n    if (!call) {\n        return undefined;\n    }\n    if (!call.address || !call.method) {\n        warnOnInvalidContractCall(call);\n        return undefined;\n    }\n    try {\n        return { address: call.address, data: call.abi.encodeFunctionData(call.method, call.args), chainId };\n    }\n    catch (_a) {\n        warnOnInvalidContractCall(call);\n        return undefined;\n    }\n}\n/**\n * Makes a call to a specific contract and returns the value. The hook will cause the component to refresh when a new block is mined and the return value changes.\n * A syntax sugar for {@link useChainCall} that uses ABI, function name, and arguments instead of raw data.\n * @public\n * @param call a single call to a contract, also see {@link ContractCall}.\n * @deprecated It is recommended to use {@link useCall} instead of this method as it is deprecated.\n * @returns the result of a call or undefined if call didn't return yet.\n */\nexport function useContractCall(call, queryParams = {}) {\n    return useContractCalls([call], queryParams)[0];\n}\n/**\n * Makes calls to specific contracts and returns values. The hook will cause the component to refresh when a new block is mined and the return values change.\n * A syntax sugar for {@link useChainCalls} that uses ABI, function name, and arguments instead of raw data.\n * @public\n * @param calls a list of contract calls , also see {@link ContractCall}.\n * @deprecated It is recommended to use {@link useCalls} instead of this method as it is deprecated.\n * @returns array of results. Undefined if call didn't return yet.\n */\nexport function useContractCalls(calls, queryParams = {}) {\n    const chainId = useChainId({ queryParams });\n    const rawCalls = useMemo(() => calls.map((call) => (chainId !== undefined ? encodeCallData(call, chainId) : undefined)), [\n        JSON.stringify(calls.map((call) => { var _a; return call && { address: (_a = call.address) === null || _a === void 0 ? void 0 : _a.toLowerCase(), method: call.method, args: call.args }; })),\n        chainId,\n    ]);\n    const results = useChainCalls(rawCalls);\n    return useMemo(() => results.map((result, idx) => {\n        const call = calls[idx];\n        if (result === '0x') {\n            warnOnInvalidContractCall(call);\n            return undefined;\n        }\n        return call && result ? call.abi.decodeFunctionResult(call.method, result) : undefined;\n    }), [JSON.stringify(results)]);\n}\n//# sourceMappingURL=useContractCall.js.map"]},"metadata":{},"sourceType":"module"}