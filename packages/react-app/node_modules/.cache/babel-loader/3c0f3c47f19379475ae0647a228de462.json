{"ast":null,"code":"import { utils } from 'ethers';\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function warnOnInvalidCall(call) {\n  if (!call) {\n    return;\n  }\n  const {\n    contract,\n    method,\n    args\n  } = call;\n  console.warn(`Invalid contract call: address=${contract.address} method=${method} args=${args}`);\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function encodeCallData(call, chainId) {\n  let queryParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _a;\n  if (!call) {\n    return undefined;\n  }\n  const {\n    contract,\n    method,\n    args\n  } = call;\n  if (!contract.address || !method) {\n    warnOnInvalidCall(call);\n    return undefined;\n  }\n  try {\n    const isStatic = (_a = queryParams.isStatic) !== null && _a !== void 0 ? _a : queryParams.refresh === 'never';\n    const refreshPerBlocks = typeof queryParams.refresh === 'number' ? queryParams.refresh : undefined;\n    return {\n      address: contract.address,\n      data: contract.interface.encodeFunctionData(method, args),\n      chainId,\n      isStatic,\n      refreshPerBlocks\n    };\n  } catch (_b) {\n    warnOnInvalidCall(call);\n    return undefined;\n  }\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function getUniqueActiveCalls(requests) {\n  const unique = [];\n  const used = {};\n  for (const request of requests) {\n    if (!used[`${request.address.toLowerCase()}${request.data}${request.chainId}`]) {\n      unique.push(request);\n      used[`${request.address.toLowerCase()}${request.data}${request.chainId}`] = true;\n    }\n  }\n  return unique;\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function getCallsForUpdate(requests, options) {\n  const callsForUpdate = [];\n  for (const request of requests) {\n    if (options) {\n      if (options.chainId && options.chainId !== request.chainId) {\n        continue;\n      }\n      if (request.isStatic && request.lastUpdatedBlockNumber !== undefined) {\n        continue;\n      }\n      const currentBlock = options.blockNumber;\n      if (currentBlock && request.lastUpdatedBlockNumber && request.refreshPerBlocks) {\n        if (currentBlock < request.lastUpdatedBlockNumber + request.refreshPerBlocks) {\n          continue;\n        }\n      }\n    }\n    callsForUpdate.push(request);\n  }\n  return callsForUpdate;\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function decodeCallResult(call, result) {\n  if (!result || !call) {\n    return undefined;\n  }\n  const {\n    value,\n    success\n  } = result;\n  try {\n    if (success) {\n      return {\n        value: call.contract.interface.decodeFunctionResult(call.method, value),\n        error: undefined\n      };\n    } else {\n      const errorMessage = new utils.Interface(['function Error(string)']).decodeFunctionData('Error', value)[0];\n      return {\n        value: undefined,\n        error: new Error(errorMessage)\n      };\n    }\n  } catch (error) {\n    return {\n      value: undefined,\n      error: error\n    };\n  }\n}","map":{"version":3,"sources":["../../../../src/helpers/calls.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { utils } from 'ethers';\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function warnOnInvalidCall(call) {\n    if (!call) {\n        return;\n    }\n    const { contract, method, args } = call;\n    console.warn(`Invalid contract call: address=${contract.address} method=${method} args=${args}`);\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function encodeCallData(call, chainId, queryParams = {}) {\n    var _a;\n    if (!call) {\n        return undefined;\n    }\n    const { contract, method, args } = call;\n    if (!contract.address || !method) {\n        warnOnInvalidCall(call);\n        return undefined;\n    }\n    try {\n        const isStatic = (_a = queryParams.isStatic) !== null && _a !== void 0 ? _a : queryParams.refresh === 'never';\n        const refreshPerBlocks = typeof queryParams.refresh === 'number' ? queryParams.refresh : undefined;\n        return {\n            address: contract.address,\n            data: contract.interface.encodeFunctionData(method, args),\n            chainId,\n            isStatic,\n            refreshPerBlocks,\n        };\n    }\n    catch (_b) {\n        warnOnInvalidCall(call);\n        return undefined;\n    }\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function getUniqueActiveCalls(requests) {\n    const unique = [];\n    const used = {};\n    for (const request of requests) {\n        if (!used[`${request.address.toLowerCase()}${request.data}${request.chainId}`]) {\n            unique.push(request);\n            used[`${request.address.toLowerCase()}${request.data}${request.chainId}`] = true;\n        }\n    }\n    return unique;\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function getCallsForUpdate(requests, options) {\n    const callsForUpdate = [];\n    for (const request of requests) {\n        if (options) {\n            if (options.chainId && options.chainId !== request.chainId) {\n                continue;\n            }\n            if (request.isStatic && request.lastUpdatedBlockNumber !== undefined) {\n                continue;\n            }\n            const currentBlock = options.blockNumber;\n            if (currentBlock && request.lastUpdatedBlockNumber && request.refreshPerBlocks) {\n                if (currentBlock < request.lastUpdatedBlockNumber + request.refreshPerBlocks) {\n                    continue;\n                }\n            }\n        }\n        callsForUpdate.push(request);\n    }\n    return callsForUpdate;\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function decodeCallResult(call, result) {\n    if (!result || !call) {\n        return undefined;\n    }\n    const { value, success } = result;\n    try {\n        if (success) {\n            return {\n                value: call.contract.interface.decodeFunctionResult(call.method, value),\n                error: undefined,\n            };\n        }\n        else {\n            const errorMessage = new utils.Interface(['function Error(string)']).decodeFunctionData('Error', value)[0];\n            return {\n                value: undefined,\n                error: new Error(errorMessage),\n            };\n        }\n    }\n    catch (error) {\n        return {\n            value: undefined,\n            error: error,\n        };\n    }\n}\n//# sourceMappingURL=calls.js.map"]},"metadata":{},"sourceType":"module"}