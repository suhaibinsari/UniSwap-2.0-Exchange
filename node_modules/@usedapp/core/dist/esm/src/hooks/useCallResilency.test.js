import { expect } from 'chai';
import { defaultAccounts, deployContract } from 'ethereum-waffle';
import { doublerContractABI, reverterContractABI } from '../constants';
import multicall2ABI from '../constants/abi/MultiCall2.json';
import { useBlockMeta, useCall, useEthers } from '../hooks';
import { renderDAppHook, setupTestingConfig } from '../testing';
import { constants, providers, Wallet } from 'ethers';
import Ganache from 'ganache';
describe('useCall Resilency tests', () => {
    for (const multicallVersion of [1, 2]) {
        for (const fastMulticallEncoding of [false, true]) {
            describe(`Multicall v${multicallVersion} configured: fastMulticallEncoding=${fastMulticallEncoding}`, () => {
                it('Other hooks work when one call reverts', async function () {
                    var _a, _b, _c, _d, _e;
                    if (multicallVersion === 1)
                        this.skip(); // This cannot work in multicall 1 as the whole batch reverts.
                    const { config, network1 } = await setupTestingConfig({ multicallVersion });
                    const revertContract = await deployContract(network1.deployer, reverterContractABI);
                    const doublerContract = await deployContract(network1.deployer, doublerContractABI);
                    const { result, waitForCurrent } = await renderDAppHook(() => {
                        const revertResult = useCall({
                            contract: revertContract,
                            method: 'doRevert',
                            args: [],
                        });
                        const doubleResult = useCall({
                            contract: doublerContract,
                            method: 'double',
                            args: [3],
                        });
                        return { revertResult, doubleResult };
                    }, {
                        config: Object.assign(Object.assign({}, config), { fastMulticallEncoding }),
                    });
                    await waitForCurrent((val) => val.doubleResult !== undefined && val.revertResult !== undefined);
                    expect((_a = result.current.revertResult) === null || _a === void 0 ? void 0 : _a.error).to.not.be.undefined;
                    expect((_b = result.current.doubleResult) === null || _b === void 0 ? void 0 : _b.error).to.be.undefined;
                    expect((_e = (_d = (_c = result.current.doubleResult) === null || _c === void 0 ? void 0 : _c.value) === null || _d === void 0 ? void 0 : _d[0]) === null || _e === void 0 ? void 0 : _e.eq(6)).to.be.true;
                });
                it('Continues to work when one call stops reverting', async () => {
                    var _a, _b, _c, _d, _e, _f;
                    const { config, network1 } = await setupTestingConfig({ multicallVersion });
                    const revertContract = await deployContract(network1.deployer, reverterContractABI);
                    const doublerContract = await deployContract(network1.deployer, doublerContractABI);
                    const { result, waitForCurrent, rerender } = await renderDAppHook((num) => {
                        const revertResult = useCall({
                            contract: revertContract,
                            method: 'revertOnOdd',
                            args: [num],
                        });
                        const doubleResult = useCall({
                            contract: doublerContract,
                            method: 'double',
                            args: [num],
                        });
                        return { revertResult, doubleResult };
                    }, {
                        config,
                        renderHook: {
                            initialProps: 5,
                        },
                    });
                    await waitForCurrent((val) => val.doubleResult !== undefined && val.revertResult !== undefined);
                    if (multicallVersion !== 1) {
                        // This cannot work in multicall 1 as the whole batch reverts.
                        expect((_c = (_b = (_a = result.current.doubleResult) === null || _a === void 0 ? void 0 : _a.value) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.eq(10)).to.be.true;
                    }
                    expect((_d = result.current.revertResult) === null || _d === void 0 ? void 0 : _d.error).to.not.be.undefined;
                    rerender(4);
                    await waitForCurrent((val) => { var _a, _b, _c; return (_c = (_b = (_a = val.doubleResult) === null || _a === void 0 ? void 0 : _a.value) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.eq(8); });
                    expect((_e = result.current.doubleResult) === null || _e === void 0 ? void 0 : _e.error).to.be.undefined;
                    expect((_f = result.current.revertResult) === null || _f === void 0 ? void 0 : _f.error).to.be.undefined;
                });
                describe('Multichain with RPC servers', () => {
                    let ganacheServers;
                    let miners;
                    let config;
                    beforeEach(async () => {
                        ganacheServers = [
                            Ganache.server({
                                chain: { chainId: 1337 },
                                logging: { quiet: true },
                                wallet: { accounts: defaultAccounts },
                            }),
                            Ganache.server({
                                chain: { chainId: 31337 },
                                logging: { quiet: true },
                                wallet: { accounts: defaultAccounts },
                            }),
                        ];
                        await ganacheServers[0].listen(18800);
                        await ganacheServers[1].listen(18801);
                        miners = [
                            new Wallet(defaultAccounts[0].secretKey, new providers.StaticJsonRpcProvider('http://localhost:18800')),
                            new Wallet(defaultAccounts[0].secretKey, new providers.StaticJsonRpcProvider('http://localhost:18801')),
                        ];
                        const multicall0 = await deployContract(miners[0], multicall2ABI);
                        const multicall1 = await deployContract(miners[1], multicall2ABI);
                        config = {
                            readOnlyChainId: 1337,
                            readOnlyUrls: {
                                [1337]: 'http://localhost:18800',
                                [31337]: 'http://localhost:18801',
                            },
                            pollingInterval: 200,
                            multicallAddresses: {
                                [1337]: multicall0.address,
                                [31337]: multicall1.address,
                            },
                        };
                    });
                    afterEach(async () => {
                        try {
                            await ganacheServers[0].close();
                        }
                        catch (_a) { } // eslint-disable-line no-empty
                        try {
                            await ganacheServers[1].close();
                        }
                        catch (_b) { } // eslint-disable-line no-empty
                    });
                    it('Continues to work when *secondary* RPC endpoint fails', async () => {
                        const { result, waitForCurrent } = await renderDAppHook(() => {
                            const { chainId, error } = useEthers();
                            const { blockNumber: firstChainBlockNumber } = useBlockMeta({ chainId: 1337 });
                            const { blockNumber: secondChainBlockNumber } = useBlockMeta({ chainId: 31337 });
                            return { chainId, secondChainBlockNumber, firstChainBlockNumber, error };
                        }, {
                            config,
                        });
                        await waitForCurrent((val) => val.chainId !== undefined &&
                            val.secondChainBlockNumber !== undefined &&
                            val.firstChainBlockNumber !== undefined);
                        expect(result.current.chainId).to.be.equal(1337);
                        expect(result.current.secondChainBlockNumber).to.be.equal(1);
                        expect(result.current.firstChainBlockNumber).to.be.equal(1);
                        await ganacheServers[1].close(); // Secondary, as in NOT the `readOnlyChainId` one.
                        await miners[0].sendTransaction({ to: constants.AddressZero });
                        await waitForCurrent((val) => val.firstChainBlockNumber === 2);
                        await waitForCurrent((val) => !!val.error);
                        expect(result.current.firstChainBlockNumber).to.be.equal(2);
                        expect(result.current.secondChainBlockNumber).to.be.equal(1);
                        expect(result.current.chainId).to.be.equal(1337);
                    });
                    it('Continues to work when *primary* RPC endpoint fails', async () => {
                        const { result, waitForCurrent } = await renderDAppHook(() => {
                            const { chainId, error } = useEthers();
                            const { blockNumber: firstChainBlockNumber } = useBlockMeta({ chainId: 1337 });
                            const { blockNumber: secondChainBlockNumber } = useBlockMeta({ chainId: 31337 });
                            return { chainId, secondChainBlockNumber, firstChainBlockNumber, error };
                        }, {
                            config,
                        });
                        await waitForCurrent((val) => val.chainId !== undefined &&
                            val.secondChainBlockNumber !== undefined &&
                            val.firstChainBlockNumber !== undefined);
                        expect(result.current.chainId).to.be.equal(1337);
                        expect(result.current.secondChainBlockNumber).to.be.equal(1);
                        expect(result.current.firstChainBlockNumber).to.be.equal(1);
                        await ganacheServers[0].close(); // Primary, as in the `readOnlyChainId` one.
                        await miners[1].sendTransaction({ to: constants.AddressZero });
                        await waitForCurrent((val) => val.secondChainBlockNumber === 2);
                        await waitForCurrent((val) => !!val.error);
                        expect(result.current.firstChainBlockNumber).to.be.equal(1);
                        expect(result.current.secondChainBlockNumber).to.be.equal(2);
                        expect(result.current.chainId).to.be.equal(1337);
                    });
                });
            });
        }
    }
});
//# sourceMappingURL=useCallResilency.test.js.map